{{- if .Values.resourceWatcherJob.enabled }}
apiVersion: v1
kind: Pod
metadata:
  name: {{ template "ckey.resourceWatcherJobName" . }}
  labels:
    app: {{ template "ckey.fullName" . }}
    release: {{ .Release.Name }}
    {{- include "ckey.customLabels" (tuple .Values.custom.job.labels .Values.global.labels ) | indent 4 }}
    {{- include "ckey.commonLabels" . | indent 4 }}
  annotations:
    {{ if .Values.istio.enabled }}
    sidecar.istio.io/inject: "true"
    {{- include "ckey.istio.resources" . }}
    {{ else }}
    sidecar.istio.io/inject: "false"
    {{ end }}
    {{- include "ckey.customAnnotations" (tuple .Values.custom.job.annotations .Values.global.annotations) | indent 4 }}
spec:
  restartPolicy: OnFailure
  serviceAccountName: {{ template "ckey.serviceAccountResourceWatcher" . }}
  automountServiceAccountToken: true
  securityContext:
{{ include "ckey.keycloak.securitycontext" . | indent 4 }}
  containers:
    {{- $thisChart := . }}
    - name: {{ template "ckey.resourceWatcherContainerName" . }}
      image: {{ include "ckey.container.image" (tuple $ .Values.images.resourceWatcherJob .Values.internalKeycloakPyRegistry) }}
      imagePullPolicy: "{{ .Values.images.pullPolicy }}"
      securityContext:
      {{- include "ckey.container.securitycontext" . | nindent 8 }}
      env:
        {{- include "ckey.timezone" . | nindent 8 }}
      command:
        - python
        - -c
        - |
          import datetime
          import logging
          import sys
          import time
          import threading
          from kubernetes import client, watch
          from kubernetes.client.rest import ApiException
          from urllib3.exceptions import ProtocolError

          log = logging.getLogger(__name__)
          out_hdlr = logging.StreamHandler(sys.stdout)
          out_hdlr.setFormatter(logging.Formatter('%(asctime)s %(message)s'))
          out_hdlr.setLevel(logging.INFO)
          log.addHandler(out_hdlr)
          log.setLevel(logging.INFO)

          # Introducing some delay before making any KubeAPI calls so that the istio-proxy container is available.
          time.sleep(5)
          with open('/var/run/secrets/kubernetes.io/serviceaccount/token','r') as file:
            serviceaccount_token = file.read()
          with open('/var/run/secrets/kubernetes.io/serviceaccount/namespace','r') as file:
            operating_namespace = file.read()

          configuration = client.Configuration()
          configuration.api_key["authorization"] = serviceaccount_token
          configuration.api_key_prefix['authorization'] = 'Bearer'
          configuration.host = 'https://kubernetes.default.svc'
          configuration.verify_ssl = True
          configuration.ssl_ca_cert = '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'

          corev1_client = client.CoreV1Api(client.ApiClient(configuration))
          appsv1_client = client.AppsV1Api(client.ApiClient(configuration))

          # Wait till at lease one pod is going to RUNNING state. CertManager in beginning of deployment make
          # change to secret which may cause unnecessary pod restart during the deployment
          def waitPodReady():
            pod_labels="app={{ template "ckey.chartName" . }},release={{ .Release.Name }}"
            podIsReady = False
            while True:
              log.info("Checking if at least one pod is ready")
              try:
                pods = corev1_client.list_namespaced_pod(operating_namespace, label_selector=pod_labels)
              except Exception as e:
                log.error("Exception when calling AppsV1Api->list_namespaced_pod: %s\n" % e)
                time.sleep(3)
                continue
              for pod in pods.items:
                if pod.status.conditions is None:
                  log.info("Condition is not available for pod!")
                  podIsReady = True
                  break
                for condition in pod.status.conditions:
                  if condition.type == 'Ready' and condition.status == 'True':
                    podIsReady = True
                    break
              if podIsReady:
                break
              time.sleep(15)

          # Restart pods included in ckey statefulset
          def restartPods():
            log.info("Restarting pods")
            now = datetime.datetime.utcnow()
            now = str(now.isoformat("T") + "Z")
            body = {
              'spec': {
                'template':{
                  'metadata': {
                    'annotations': {
                      'kubectl.kubernetes.io/restartedAt': now
                    }
                  }
                }
              }
            }
            try:
              appsv1_client.patch_namespaced_stateful_set("{{ template "ckey.keycloak.statefulsetName" . }}", operating_namespace, body, pretty='true')
            except ApiException as e:
              log.error("Exception when calling AppsV1Api->patch_namespaced_stateful_set: %s\n" % e)

          # Monitor events provided by k8s function defined in parameter selector_func
          # Restart pods if it is MODIFIED event on the object annotated by restartOnUpdate
          def watchEvents(selector_func, threadName):
            while True:
              try:
                waitPodReady()
                log.info("Monitoring " + threadName + "...")
                w = watch.Watch()
                for event in w.stream(selector_func, namespace=operating_namespace, watch=True, timeout_seconds=7200):
                  if event['type'] == "MODIFIED":
                    if event['object'].metadata.to_dict().get('annotations') is not None:
                      if event['object'].metadata.annotations.get('restartOnUpdate') is not None:
                        log.info("Object {} is modified".format(event['object'].metadata.name))
                        restartPods()
              except ProtocolError as e:
                log.error("Protocol Exception occurred : {} \n Skipping the exception".format(e))
              except ApiException as ex:
                log.error("Exception when calling CoreV1Api -> list_namespaced_secret: {}".format(ex))

          # Class to implement parallel threads
          class watcherThread (threading.Thread):
            def __init__(self, threadName):
              threading.Thread.__init__(self)
              self.threadName = threadName
            def run(self):
              if self.threadName == "WatchSecrets":
                watchEvents(corev1_client.list_namespaced_secret, self.threadName)
              if self.threadName == "WatchConfigMaps":
                watchEvents(corev1_client.list_namespaced_config_map, self.threadName)

          # Starting 2 parallel threads for watching secret and config map events
          def runWatchingThreads():
            # my comment2
            thread1 = watcherThread("WatchSecrets")
            thread2 = watcherThread("WatchConfigMaps")
            thread1.start()
            thread2.start()
            threads = []
            threads.append(thread1)
            threads.append(thread2)
            for t in threads:
              t.join()

          runWatchingThreads()
          exit()

      resources:
{{ include "ckey.keycloak.busybox-container-resources-spec" . | indent 8 }}

  {{- if .Values.nodeSelector }}
  nodeSelector:
{{ toYaml .Values.nodeSelector | indent 4 }}
  {{- end }}
  {{- include "ckey.imagePullSecrets" (tuple . "resourceWatcherJob") | nindent 2 }}
  {{- if .Values.tolerations }}
  tolerations:
{{ toYaml .Values.tolerations | indent 4 }}
  {{- end }}
{{ include "ckey.common.affinity" . | indent 2 }}
{{ end }}

#------------------------------------------------------------------------------
# KSQL Server default values:
#------------------------------------------------------------------------------
global:
  # This registry references to delivered images.
  registry: csf-docker-delivered.repo.cci.nokia.net
       
  # If flatRegistry is set to true then, user is open to use their own flat registries. By default flatRegistry is set to false.
  # When flatRegistry is enabled then repo path will not be used.
  flatRegistry: false
                 
  seccompAllowedProfileNames: runtime/default
  seccompDefaultProfileName: runtime/default
  #Refer section "LabelsandAnnotations" from the Helm Best Practices documentation
  annotations:
  #Add the annotations here
  labels:
  #Add the labels here
  #Refer section "CommonLabels" from the Helm Best Practices documentation  
  common_labels: true
  rbac:
    enabled: true
  preheal: 0
  postheal: 0
  clog:
    enabled: true
  #unifiedLogging.extension has precedence over global.unifiedLogging.extension
  #extension accepts key: value pair
  #example:
  #unifiedLogging:
  #  extension:
  #    component: ckaf
  #    ns_uuid: 123  
  unifiedLogging:
    extension: {}
    syslog:
      enabled: false
      host:
      port:
      facility:
      protocol: "UDP"
  # Enable this flag to set default pod CPU resources limit in all containers. Default value is set to false
  enableDefaultCpuLimits: false
  # prefix for the resource names
  podNamePrefix:
  # parameter to disable PodNamePrefixRestrictions
  #If disablePodNamePrefixRestrictions set to true, it will not limit the length of <podNamePrefix> to 30 characters
  disablePodNamePrefixRestrictions: false
  # To ensure that logs and other data use a common timezone configure timeZoneEnv.Defaults to UTC
  timeZoneEnv: ""
  #enabled value left empty intentionally, default value is False
  hpa:
    enabled:
  #GenericEphermalVolume
  #enabled value left empty intentionally, default value is False
  #emptyDir is used by Default
  #ephemeralVolume.enabled has precedence over global.ephemeralVolume.enabled
  ephemeralVolume:
    enabled:
  # istio configurations
  istio:
    # Supports istio version > 1.4
    version: 1.6
    # setting "enabled: true" injects istio proxy side cars to the ksql pods.
    enabled: false
    # Whether istio cni is enabled in the environment.
    cni:
      enabled: true
    # MTLS section of configuration.
    # if mtls.enabled==true and permissive==true, will create peerauthentication with mtls mode PERMISSIVE for ksql.
    # if mtls.enabled==false and permissive==false, will create peerauthentication with mtls mode STRICT for ksql.
    mtls:
      #Is strict MTLS enabled in the environment.
      enabled: false
    # Should allow mutual TLS as well as clear text for your deployment.
    permissive: true
    envoy:
      # Health check port of istio envoy proxy.
      healthCheckPort: 15021
      # Port used to terminate istio envoy sidecar using /quitquitquit endpoint
      stopPort: 15000


    # Optional sharedHttpGateway which should be used if you need to share a gateway.
    sharedHttpGateway:
      # This section instructs the chart to reuse an already existing gateway for http/https purposes.
      # This is applicable if you already have a gateway on the same hostname listening on 80/443.
      # Namespace where the existing gateway object exists.
      namespace:
      # Name of the gateway object.
      name:
    # An optional array of gateways which can be added if needed.These gateways will be created fresh in your install.
    gateways:
    # Name of the gateway.
    - name:
      # Should this be enabled or not.
      enabled: false
      # Optional labels to be added to gateway object.
      labels: {}
      # Any annotations to be added to the gateway object.
      annotations: {}
      # By default the chart will use label 'istio: ingressgateway' as selector which is the default one deployed in istio-system namespace.
      # This should be the label of the istio ingressgateway pod which you want your gateway to attach to.
      ingressPodSelector:
        istio: ingressgateway
      # Port number where the gateway should attach to.
      port: 443
      # Tested ksql with (HTTP/HTTPS). HTTPS will need the optional tls section to be filled.
      protocol: HTTPS
      # By default the chart will use '*'. It can be a YAML array of host names.
      hosts: []
      # TLS settings for your gateway.This section is mandatory if protocol is HTTPS.
      tls:
        # This optional flag is only applicable for an HTTP port to force a redirection to HTTPS.
        redirect:
        # Mode can be SIMPLE / MUTUAL / PASSTHROUGH/ and it is exactly as per ISTIO documentation.
        mode:
        # The name of the kubernetes secret, in the namespace to be used for TLS traffic.
        credentialName:
        # Istio TLS has many other attributes and configurations.If for some reason none of the above fits your
        # needs , then use this section to configure as per istio docs. Anything under here will be directly moved
        # under TLS section of gateway definition.
        custom: {} 
  # Specify the PriorityClass name for ksql deployment.
  # If left blank or empty quotes, pods will be configured with priorityClassName config at root level or cluster default PriorityClass.
  # See https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""
  # For IPv4 and IPv6 dual stack support
  # ipFamilyPolicy:  SingleStack | PreferDualStack | RequireDualStack
  ipFamilyPolicy: 
  # ipFamilies: ["IPv4"] | ["IPv6"] | ["IPv4","IPv6"] | ["IPv6","IPv4"]
  ipFamilies: []
  imagePullSecrets:
  # Accepts array of secret name
  #  - registry-cred-secret1
  #  - registry-cred-secret2 
  
  certManager:
    enabled: true

  imageFlavor: "rocky8"
  imageFlavorPolicy:

# workload level scope

imageFlavor:
imageFlavorPolicy:

imagePullSecrets:

ipFamilyPolicy:
ipFamilies: []

#Release is the release name mentioned by the user while installing the chart
topologySpreadConstraints: []
#  - maxSkew: 1
#    topologyKey: zone
#    whenUnsatisfiable: DoNotSchedule/ScheduleAnyway
#    labelSelector:
#      matchLabels:
#        app: ckaf-ksql
#        release: 'ksql'
#    autoGenerateLabelSelector: False

podAntiAffinity:
  zone:
    #Possible options: soft/hard/none
    type:
    topologyKey: "topology.kubernetes.io/zone"
  node:
    #Possible options: soft/hard/none
    type:
    topologyKey: "kubernetes.io/hostname"
  customRules:
    #- type: soft/hard (by default soft)
    #  topologyKey:
    #  weight: 100 (by default 100)
    #  autoGenerateLabelSelector: true
    #  labelSelector: <pod labels> (none by default)
    #  namespaceSelector: <namespace labels> (none by default)
    #  namespaces:

# To ensure that logs and other data use a common timezone configure timeZoneEnv.
# This has precedence over the global level timeZoneEnv.  
timeZone:
  timeZoneEnv: ""

accessRoleLabel: internal-access

#unifiedLogging.extension has precedence over global.unifiedLogging.extension
#extension accepts key: value pair
#example:
#unifiedLogging:
#  extension:
#    component: ckaf
#    ns_uuid: 123

# To forward logs to the syslog server enable syslog.enabled to "true"
# As of now ckaf components only support UDP protocol to fwd the logs,
# since log4j1/slf4j only supports  UDP.
unifiedLogging:
  extension: {}
  syslog:
    enabled:
    host:
    port:
    facility:
    protocol: "UDP"
# Enable this flag to set default pod CPU resources limit in all containers. Default value is set to false
enableDefaultCpuLimits: true
#If disablePodNamePrefixRestrictions set to true, it will not limit the length of <podNamePrefix> to 30 characters
disablePodNamePrefixRestrictions:
# Enable this flag to set resource name with new HBP 3.7 convention. The default values is set to false. If the flag is set to true during upgrade, there can be data loss due to name change.
installWithNewResourceNameConvention: false

#GenericEphermalVolume
#enabled value left empty intentionally, default value is False
#When ephemeralVolume.enabled is set to false emptyDir is used.
#ephemeralVolume.enabled has precedence over global.ephemeralVolume.enabled
ephemeralVolume:
  enabled:
  storageClass: ""
  #volumes used to load the plugins into plugin-initcontainer and ckaf-ksql conatiner.
  #storageSize of pluginsmount
  storageSize:
    pluginsmount: 1Gi

clusterDomain: "cluster.local"

managedBy: Helm
name: Analytics

certManager:
  enabled: false

# workload level annotations/labels
ksqlDeploymentset:
  annotations:
  #Add the annotations here
  labels:
  #Add the labels here
# Pod level annotations/labels
ksqlPodLevel:
  annotations:
  #Add the annotations here
  labels:
  #Add the labels here   

# Configure ksql specific annotations/labels below. Use 6 space indentation
custom:
  # workload level annotations/labels
  ksqlDeploymentset:
    annotations:
    #Add the annotations here    
    labels:
    #Add the labels here
  #pod level annotations/labels
  ksqlPodLevel:
    annotations:
    #Add the annotations here
    labels:
    #Add the labels here

#This section allows to configure user defined name for component resources
# Options include:
# nameOverride: use this to have 'ckaf-ks'-'user-defined' naming convention.
# fullnameOverride: use this to have custom name for all the resources.
# default (below parameters commented): <releasename>-ckaf-ksql  naming convention.
# If specified both, fullnameOverride would take the precedence.

#nameOverride: "user-defined"
#fullnameOverride: "user-defined"

init:
  imageRepo: ckaf/ckaf-kafka-init
  #deprecated: imageName will be used instead of imageRepo when flatRegistry is set to true.
  imageName: ckaf-kafka-init
  imageTag: 9.1.0-rocky8-jre17-4.1.0-8675
  imageFlavor:
  imageFlavorPolicy:
  # _imageFlavorMapping is a constant variable and users are not allowed to modify in this section. Changes in this section will impact chart installation.
  _imageFlavorMapping:
    - flavor: "rocky8-jre17"
      tag: "9.1.0-rocky8-jre17-4.1.0-8675"
      repository: "ckaf/ckaf-kafka-init"
    - flavor: "rocky8-jre11"
      tag: "9.1.0-rocky8-jre11-4.1.0-8675"
      repository: "ckaf/ckaf-kafka-init"

# Enable this feature to load ksql custom plugins via init container.
# loadPluginsFromInitContainer: enable/disable custom plugins loader.
# pluginsInitContainerImageName : init container docker image name
# pluginsInitContainerImageTag : init container docker image tag.
# pluginsInitContainerImagePullPolicy: pull policy for docker image.
# pluginsBasePath : < basepath in the init docker image consisting of 
#                    custom ksql plugin jars for ex custom udf uber jar >.
loadPluginsFromInitContainer: false 
pluginsInitContainerResources:
  requests:
    cpu: 200m
    memory: 1Gi
    ephemeral-storage: 1G
  limits:
    cpu: ""
    memory: 1Gi
    ephemeral-storage: 1G
pluginsInitContainerImageName: ""
pluginsInitContainerImageTag: ""
pluginsInitContainerImagePullPolicy: "IfNotPresent"
pluginsBasePath: ""

# Number of KSQL server pod 
replicaCount: 1

replicasManagedByHpa: False

_kind: Deployment

# Don't left the below field blank. Either set a unique name or keep it with default value.
_objectNameTemplate: '{{ include "ckaf-ksql.name" . }}'

hpa:
  #enabled value left empty intentionally, default value is False
  enabled:
  minReplicas: 1
  maxReplicas: 4
  predefinedMetrics:
    enabled: True
    averageCPUThreshold: 80
    averageMemoryThreshold: 80
  behavior:
  metrics:


## Image Info
# KSQL server image
image: ckaf/ckaf-ksql
imageRepo: ckaf/ckaf-ksql
#imageName will be used instead of imageRepo when flatRegistry is set to true.
imageName: ckaf-ksql
imageTag: 9.1.0-rocky8-jre17-7.5.3-8675

# Kubectl image
kubectlImageRepo: tools/kubectl
#Deprecated : kubectlImageName will be used instead of kubectlImageRepo when flatRegistry is set to true.
kubectlImageName: kubectl
kubectlTag: "1.28.7-rocky8-nano-20240301"

kubectl:
  imageFlavor:
  imageFlavorPolicy:
  # _imageFlavorMapping is a constant variable and users are not allowed to modify in this section. Changes in this section will impact chart installation.
  _imageFlavorMapping:
    - flavor: "rocky8"
      tag: "1.28.7-rocky8-nano-20240301"
      repository: "tools/kubectl"
  imagePullPolicy: "IfNotPresent"

# Specify a imagePullPolicy
# ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
imagePullPolicy: IfNotPresent

# Configure PodDisruptionBudget here
# Specify the minimum number of pods that must be available after the eviction, even in the absence of the evicted pod.
# Either set minAvailable or maxUnavailable but not both. Values can be numeric like 1,2,3 or percentage like 50%.
pdb:
  enabled: false
  #maxUnavailable: 0
  minAvailable: 1


# Specify the PriorityClass name for ksql deployment.
# If left blank or empty quotes, pods will be configured with global.priorityClassName if defined or cluster default PriorityClass.
# See https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
priorityClassName: ""

# KSQL server listening port
servicePort: 8088

# KSQL server JVM Heap Option
heapOptions: "-Xms512M -Xmx512M"

# KSQL log4j
LogLevel: "INFO"
MaxFileSize: 50MB
MaxBackupIndex: 10

# KSQL gc logging
# CAUTION: If gc log is set to true, do not change the LOG_DIR from /var/log/ksql to any other directory
gcLog:
  enabled: false
  ksqlGcLogOpts: "-Xlog:gc*:file=/var/log/ksql/ksql-test.log:time,tags:filecount=10,filesize=102400"

# KSQL pod security policy
security:
  enabled: true
  runAsUser: 999
  runAsGroup: 998
  fsGroup: 998
  readOnlyRootFilesystem: true
  seccompProfile:
    type: "RuntimeDefault"

# KSQL server resources
# ref: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
resources:
  requests:
    cpu: 500m
    memory: 2Gi
    ephemeral-storage: 1G
  limits:
    cpu: ""
    memory: 4Gi
    ephemeral-storage: 1G

# KSQL job resources for LCM events
jobResources:
  requests:
    cpu: 200m
    memory: 1Gi
    ephemeral-storage: 200M
  limits:
    cpu: ""
    memory: 4Gi
    ephemeral-storage: 200M

#KSQL init container resources
initContainerResources:
  limits:
    cpu: ""
    memory: 256Mi
    ephemeral-storage: 500M
  requests:
    cpu: 100m
    memory: 128Mi
    ephemeral-storage: 500M

# KSQL helm test resources
helmTestResources:
  requests:
    cpu: 0.25
    memory: 128Mi
    ephemeral-storage: 50M
  limits:
    cpu: ""
    memory: 256Mi
    ephemeral-storage: 50M


# Custom pod annotations
podAnnotations: {}

livenessProbe:
  initialDelaySeconds: 10
  periodSeconds: 15
readinessProbe:
  initialDelaySeconds: 10
  periodSeconds: 15

# Adding entries to a Podâ€™s /etc/hosts file provides Pod-level override of hostname resolution
# eg. configuration:
# hostAliases:
# - ip: "10.99.26.136"
#   hostnames:
#   - "vm-10-99-26-136"
#   - "mytestvm"
# - ip: "10.99.26.135"
#   hostnames:
#   - "vm-10-99-26-135"
hostAliases: []

# Node labels for pod assignment
# ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
# Add user defined label under nodeLabel as key value pair. 
# Enable it to true to use nodeLabel feature
# Always quote the value part. Example nodeType: "ksql-enable"
# Example:
# ksqlNodeSelector:
#   enable: true
#   nodeLabel:
#     "key1" : "value1"
ksqlNodeSelector:
  enable: false
  nodeLabel:

# toleration can be added for three types of taints : NoSchedule, PreferNoSchedule and NoExecute
# operator can also be given as Exists and value parameter can be omitted in that case
# tolerationSeconds (in seconds) can be added as part of NoExecute toleration that specifies how long the pod will stay bound after the node tainting.
# Multiple tolerations can be added
# Example: 
# tolerations:
# - key: "testing1"
#   operator: "Equal"
#   value: "no1"
#   effect: "NoSchedule"
# - key: "testing2"
#   operator: "Exists"
#   effect: "NoExecute"
#   tolerationSeconds: 120
# toleration matches a taint if key and effect is same. 
# An empty 'key' with operator Exists will tolerate everything as it matches all keys, values and effects.
# Example: 
# - operator: "Exists"
# An empty 'effect' matches all effects with key 'key'
# Example:
# - key: "key"
#   operator: "Exists"
tolerations: []

# enable external access using ingress.
ingress:
  enabled: false
  tls:
    enabled: true
    secretName: ""
  path:
  pathType: Prefix
  annotations: {}
  #If user wants to modify the default path, please add the annotation
  #"nginx.ingress.kubernetes.io/rewrite-target:" in line with the path.
  #route.openshift.io/termination: "passthrough"
  #Use this annotation when the chart install at openshift environment.
  #When this annotation is used make sure to set path to '' and pathType to ImplementationSpecific
ingressNbi:
  enabled: false
  tls:
    enabled: true
    secretName: ""
  path:
  pathType: Prefix
  annotations: {}
    #If user wants to modify the default path, please add the annotation
    #"nginx.ingress.kubernetes.io/rewrite-target:" in line with the path.
    #route.openshift.io/termination: "passthrough"
    #Use this annotation when the chart install at openshift environment.
    #When this annotation is used make sure to set path to '' and pathType to ImplementationSpecific

JmxExporter:
  enabled: true
  imageRepo: "cpro/cpro-jmx-exporter"
  #deprecated: imageName will be used instead of imageRepo when flatRegistry is set to true.
  imageName: "cpro-jmx-exporter"
  imageTag: "4.1.0-rocky8-0.20.0-3612"
  imageFlavor:
  imageFlavorPolicy:
  # _imageFlavorMapping is a constant variable and users are not allowed to modify in this section. Changes in this section will impact chart installation.
  _imageFlavorMapping:
    - flavor: "rocky8"
      tag: "4.1.0-rocky8-0.20.0-3612"
      repository: "cpro/cpro-jmx-exporter"
  imagePullPolicy: "IfNotPresent"
  port: 5556
  jmxResources:
    resources:
      requests:
        cpu: 100m
        memory: 1Gi
        ephemeral-storage: 200M
      limits:
        cpu: ""
        memory: 4Gi
        ephemeral-storage: 200M
  tls:
    enabled: false
    # provide the certificate alias name in case of user generated certificates.
    # defaults to certificate as to match the cert-manager generated certificates.
    certificateAlias: "certificate"
    secretRef:
      # Secret name, pointing to a Secret object.
      # If empty then automatically generated secret with certManager certificate will be used
      name:
      # Secret key names mapping.
      keyNames:
        # Keys for JKS format certificates.
        # password keys are mandatory in case of JKS format certificates
        keystore_key: keyStore
        truststore_key: trustStore
        truststore_passwd_key: trust
        keystore_passwd_key: key
  certificate:
    # Certificate object is created based on the data in this section.
    issuerRef:
      # We can refer different Issuers by changing the kind here.
      # The default value is ncms-ca-issuer(i.e is a cluster issuer)
      name: ncms-ca-issuer
      kind: ClusterIssuer
      group: cert-manager.io
    duration: "8760h" # 365d
    renewBefore: "360h" # 15d
    # If left empty, it will be generated automatically.
    secretName:
    # Not needed in internal communication
    subject:
    # It has been deprecated since 2000 and is discouraged from being used for a server side certificates.
    # `dnsNames` are used instead.
    commonName:
    # Usages is the set of x509 usages that are requested for the certificate.
    usages:
    # DNSNames is a list of DNS subjectAltNames to be set on the Certificate.
    dnsNames:
    # URIs is a list of URI subjectAltNames to be set on the Certificate.
    uris:
    # IPAddresses is a list of IP address subjectAltNames to be set on the Certificate.
    ipAddresses:
    # password for the keystore file to be provided as a secret.
    # Note: same password wil be used to encrypt the trustore, keystore and keypasswords.
    # if the format of certificates is PEM then this need not be provided.
    store_password_secret_name: <user-defined>
    store_password_key: <user-defined>
    privateKey:
      # allowed values for algorithm are 'RSA','Ed25519' or 'ECDSA'
      algorithm: "RSA"
      # allowed values for encoding are 'PKCS1' or 'PKCS8'
      # Only 'PKCS8' is supported for PEM Certificates
      encoding: "PKCS1"
      size: "2048"
      # Rotation of a key pair, when certificate is refreshed is recommended from a security point of view
      rotationPolicy: Always


## Headless mode
## ref: https://docs.confluent.io/current/ksql/docs/installation/server-config/index.html
# if giving the custom config map, the queries.sql file in the root folder is redundant and will not be used i.e precedence is always given to custom config map file.
#kubectl create configmap <ksqlQueriesConfigMapName> --from-file=<queriesFileKey>=<path-to-queries-file>
ksql:
  headless: false
  ksqlQueriesConfigMapName: 
  queriesFileKey:
  #Consider increasing the sleepTime if the queries are huge. By default sleepTime is 30 seconds.
  sleepTime: 30
  imageFlavor:
  imageFlavorPolicy:
  # _imageFlavorMapping is a constant variable and users are not allowed to modify in this section. Changes in this section will impact chart installation.
  _imageFlavorMapping:
    - flavor: "rocky8-jre17"
      tag: "9.1.0-rocky8-jre17-7.5.3-8675"
      repository: "ckaf/ckaf-ksql"
    - flavor: "rocky8-jre11"
      tag: "9.1.0-rocky8-jre11-7.5.3-8675"
      repository: "ckaf/ckaf-ksql"
 
# Kafka service to bootstrap ksql-server
# Example bootstrapServers: "PLAINTEXT://kf-my-kaf-headless.namespace.svc.cluster.local:9092"
# or "SSL://kf-my-kaf-headless.namespace.svc.cluster.local:9092"
kafka:
  bootstrapServers: ""

# Schema registry service and port
# e.g. http://schema-registry-my-sr-headless.namespace.svc.cluster.local:8081
# or https://schema-registry-my-sr-headless.namespace.svc.cluster.local:8081
schema-registry:
  url: ""

# KSQL configuration options
## ref: https://docs.confluent.io/current/ksql/docs/installation/server-config/config-reference.html
configurationOverrides:
  "confluent.support.metrics.enable": "false"
  #For better fault tolerance and durability, set the replication factor for the internal topics that Kafka Streams creates for some queries.
  #"ksql.streams.replication.factor": "3"
  #For better fault tolerance and durability, set the replication factor for the KSQL Server's internal topics
  #"ksql.internal.topic.replicas": "3"
  #Number of stream threads in an instance of the Kafka Streams application
  #"ksql.streams.num.streams.thread": "3"
  #Number of replicas for the topics created by KSQL
  #"ksql.sink.replicas": "3"
  #If set to true, then KSQL will automatically try to create a processing log topic at startup.
  #"ksql.logging.processing.topic.auto.create": "false"
  #If automatic processing log topic creation is enabled, KSQL creates the topic with number of replicas set to the value of this property
  #"ksql.logging.processing.topic.replication.factor": "3"

# KSQL security related
# ref: https://docs.confluent.io/current/ksql/docs/installation/server-config/security.html
KafkaKsql:
  security:
    kafka:
      sasl:
        enabled: false
        #possible values "GSSAPI" or "PLAIN"
        mechanism: "GSSAPI"
      tls:
        enabled: true
    schema:
      tls:
        enabled: true
        basePath: /etc/ksql/ssl/schema
        protocol: "TLSv1.2"
        enabledProtocols: "TLSv1.2,TLSv1.3"
        secretRef:
          name:
          keyNames:
            keystore_key:
            truststore_key:
            truststore_passwd_key:
            keystore_passwd_key:
            keystore_key_passwd_key:
      # if schema-registry basic auth is enabled, client to use SASL_INHERIT as the credential source
      # turn ON the flag "saslInheritAuthentication" to true
      basicAuth:
        saslInheritAuthentication: false
    rest:
      tls:
        enabled: true
    kafkaRest: 
      # To connect kafka(TLS enabled) and start ksql with HTTPS protocol, KSQL uses common keystore and truststore mounted
      # using below secret. Make sure to copy public cert of Kafka in truststore or use common CA.
      tls:
        basePath: /etc/ksql/ssl/kafka
        # Configures ksql to request client authentication.
        # To enable set it to true
        clientAuth: false         
        secretRef:
          name:
          keyNames:
            keystore_key:
            truststore_key:
            truststore_passwd_key:
            keystore_passwd_key:
            keystore_key_passwd_key:
  sasl:
    krb:
      # provide the krb5.conf as a configmap
      # kubectl create configmap <krbConfigmapName> --from-file=<KrbConfKeyName>=<path to krb5.conf>
      krbConfigmapName:
      KrbConfKeyName:
      # If KafkaKsql.security.kafka.sasl.enabled and KafkaKsql.security.kafka.sasl.mechanism="GSSAPI",create secret containing
      # the principal-name and keytab-file which will be used to login to kdc-server,using the below kubectl command.
      # kubectl create secret generic <secret-name> --from-literal=<krbPrincipalKeyName>=<principal-name> --from-file=<krbKeytabKeyName>=<keytab-path> 
      kafka:
        krbSecretName:
        krbPrincipalKeyName:
        krbKeytabKeyName:
        krbSaslKerberosServiceName:
    plain:
      kafka:
        secretName:
        usernameKey:
        passwordKey:
      # section to provide the username and password as secret; if schema-registry is enabled with basic authentication,
      # and clients need to use SASL_INHERIT as credential source
      # for eg: 
      # kubectl create secret generic <secretname> --from-literal=<usernameKey>=<username> --from-literal=<passwordKey>=<password>
      schemaRegistry:
        secretName: <secretname>
        usernameKey: <usernameKey>
        passwordKey: <passwordKey>
      
  tls:
    enabledProtocols: "TLSv1.2,TLSv1.3"
    protocol: "TLSv1.2"    
  ssl:
    # To connect kafka(TLS enabled) and start ksql with HTTPS protocol, KSQL uses common keystore and truststore mounted using
    # below secret. Make sure to copy public cert of Kafka in truststore or use common CA.
    enabledProtocols: "TLSv1.2,TLSv1.3"
    protocol: "TLSv1.2"    
    kafkarestssl:
      sslSecretName: 
      sslKeyStoreLocationKey: 
      sslTrustStoreLocationKey: 
      sslKeyStorePassKey: 
      sslTrustStorePassKey: 
      sslKeyPassKey: 
      sslBasePath: /etc/ksql/ssl/kafka
      # Configures ksql to request client authentication.
      # To enable set it to true
      clientAuth: false         
    schema:
      sslEnabledProtocols: "TLSv1.2,TLSv1.3"
      sslProtocol: "TLSv1.2"
      sslSecretName: 
      sslKeyStoreLocationKey: 
      sslTrustStoreLocationKey: 
      sslKeyStorePassKey: 
      sslTrustStorePassKey: 
      sslKeyPassKey: 
      sslBasePath: /etc/ksql/ssl/schema

  #this section is used when certmanager is enabled
  certificate:
    enabled: false
    # If left empty, it will be generated automatically.
    secretName:
    duration: 8760h
    renewBefore: 360h
    # Not needed in internal communication
    subject:
    # It has been deprecated since 2000 and is discouraged from being used for a server side certificates.
    # `dnsNames` are used instead.
    commonName:
    usages:
      - server auth
      - client auth
    dnsNames: []
    # URIs is a list of URI subjectAltNames to be set on the Certificate.
    uris:
    # IPAddresses is a list of IP address subjectAltNames to be set on the Certificate.
    ipAddresses:
    privateKey:
      algorithm: "RSA"
      encoding: "PKCS1"
      size: "2048"
      # Rotation of a key pair, when certificate is refreshed is recommended from a security point of view
      rotationPolicy: Always
    keystores:
      jks:
        create: true
        passwordSecretRef:
          key: <user-defined>
          name: <user-defined>
    issuerRef:
      name: ncms-ca-issuer
      kind: ClusterIssuer
      group: cert-manager.io

#certificate
initContainer:
  image:
    name: fnms-init-container
    tag: nokia-1.0.9
    pullPolicy: IfNotPresent
certificates:
  secrets:
    altiplano_keystore_secrets: altiplano-keystore-secrets
  fileNames:
    kafka_server_key_pem: kafka-server-key.pem
    kafka_server_key_pass: kafka-server-key.pass
    kafka_server_cert_pem: kafka-server-cert.pem
    altiplano_keystore_password: keystore-password
    kafka_server_keystore_jks: server.jks
    kafka_server_trustchain_cert_pem: kafka-server-trustchain-cert.pem
    kafka_server_truststore_jks: trustchain.jks

defaultSecurity:
  enabled: true
  runAsUser: 1000
  fsGroup: 1000
  runAsGroup: 1000
